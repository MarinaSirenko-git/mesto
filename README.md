# Яндекс.Практикум / Проект Mesto
![Mesto](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-04-06_at_6.36.00_PM_1589715787.png "Mesto")

### Задачи
01. Настроить сборку проекта Вебпаком
02. Верстка должна попиксельно совпадать с [макетом](https://www.figma.com/file/StZjf8HnoeLdiXS7dYrLAh/JavaScript.-Sprint-4)
03. Шрифты должны быть подключены локально, изображения оптимизированы
04. Контент должен легко читаться спомощью скринридера
05. Именование классов и файловая структура реализованы в соответствии с БЭМ
06. Корректное отображение на экранах разных размеров
07. Реализовать возможность менять изображение аватара через форму в попапе
08. Реализовать возможность менять информацию пользователя через форму в попапе
09. Реализовать возможность добавлять изображение, ставить ему лайк или удалять
10. При открытии страницы показывать добавленные изображения всех пользователей
11. При клике на карточку изображения показывать попап с полноразмерным изображением и подписью
12. Настроить валидацию формы
13. Настроить закрытие попапов по клику на Х, Overlay, нажатию на ESC

### Технологии проекта

`HTML5`, `CSS3`, `CSS Flexbox`, `BEM Nested`, `JavaScript`

### Решение
1. Устанавливаем зависимости, пишем конфиги. Для разработки нам понадобится: сам сборщик webpack, интерфейс командной строки для webpack, сервер для разработки, очистка проекта перед сборкой, плагин, подключающий html файл, загрузчик css файлов подключенных через @import и url(), плагин объединяющий css файлы, загрузчик PostCSS и несколько его расширений, Babel транспилятор, а вместе с ним набор правил преобразования, полифилы и загрузчик, плагин для публикации на gh-pages. Для итогового проекта нам понадобятся только полифилы npm i core-js --save. Фух...можно выпить чашечку чая :)
2. Собирем каркас страницы, используя семантичные теги, добавляем alt изображениям, aria-label кнопкам иконкам и инпутам, проверяем через валидатор, слушаем через скринридер.
3. Выделяем блоки, элементы. Создаем структуру по БЭМ. Используем PerfectPixel и пишем правила CSS.
4. Добавляем правила для медиа-запросов. Минимальная ширина: 320px. Максимальная: 1280px.
5. Динамические элементы, в данном случае изображения мест - реализуем через тег template, потому что insertAdjacentHTML открывает XSS-уязвимость в безопасности сайта, а методы createElement, append добавят кучу плохо читаемого кода.
6. Оживляем верстку. На каждую функциональную сущность напишем класс с приватными и публичными методами. Итого для запросов к серверу Api, для функционала карточки Card, для настройки валидации FormValidator, для попапа Popup (от него унаследуют три дочерних класса), для информации о пользователе UserInfo.
7. Вставлять готовую разметку на страницу будет класс Section. Разметка будет приходить в Section из любого класса, который её генерирует.
8. Ипользуем слабое связывание через функции-колбеки

### Ошибки на ревью
1. Неудаленный обработчик. Современные браузеры при удалении DOM элемента удаляет и его слушатели. 
Но есть в проекте обработчик нажатия на ESC (для закрытия popup), который повешен на document и который удалится, только если мы ему поможем.
Чтобы удалить событие, нужно передать функцию в событие не вызывая её. Привязка к this через bind `div.addEventListener('click', listener.bind(this))`, тоже приравнивается к вызову функции.
Выход, например, такой: в конструкторе реализовать привязку к this `this._handleEscClose = this._handleEscClose.bind(this);` и передавать ссылку в событие удаления.
2. Код богат на лишние действия. А именно, поиск элемента в DOM нужно выносить из метода в конструктор, тем более если к этому элементу идет обращение из нескольких методов. 
Передавать часть кода ф-ии в переменную, нужно при условии, что она пригодится где-то ещё помимо этой ф-ии, инче код читать труднее. Классовую переменую можно определить прямо в методе (если в конструктор вынести невозможно) и из других методов этого класса, она также будет доступна. 
3. Нейминг. Имя ф-и или метода начинается с глагола, например, отрисовывает элемент на странице - **renderCardItem**, генерирует элемент - **generateCard**, 
получает значение - **getArifmeticalProgression**. При работе с массивом данных использовать множественное число - **renderElements**
4. Экземпляры класса создаются вне обработчиков событий, внутри обработчика только методы экземпляров (если методы добавляют слушатели, также вызывать за пределами обработчиков). Иначе баги.
---------
Ссылка на проект  https://marinasirenko-git.github.io/mesto/
